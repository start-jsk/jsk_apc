#!/usr/bin/env python
import argparse
import copy
import json
import sys

'''
    This script is designed to check Task Input Files [1] used for testing
    against the pick and stow tasks defined in the Amazon Picking Challenge
    2016 rules. It is used to confirm the files generated by the
    interface_generator_2016.py script are correct, and is provided so you
    can check any custom files you develope.

    Usage: python interface_test_2016.py PICK_FILENAME [STOW-FILENAME]
        If only 1 file is supplied, it is assumed to be a pick task.
        If 2 files are supplied, the 1st is assumed to be a pick task, and the
            2nd is assumed to be a stow task.
        Additional inputs are unsupported.
        The script will provide colorized text output as to the correctness of
            each file, and will attempt to provide detail as to any mistakes
            that may have been encountered.

    [1] http://amazonpickingchallenge.org/APC_2016_Official_Rules.pdf,
        section 'Task Attempt Rules', paragraph 2.
'''
# define a terminal-output color class


class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# -------------------------------------------------------------------------


# -------------------------------------------------------------------------

# define some known constants to compare against
CONST_BIN_NAMES = ['bin_A',
                   'bin_B',
                   'bin_C',
                   'bin_D',
                   'bin_E',
                   'bin_F',
                   'bin_G',
                   'bin_H',
                   'bin_I',
                   'bin_J',
                   'bin_K',
                   'bin_L']
CONST_ITEM_NAMES = ["i_am_a_bunny_book",
                    "laugh_out_loud_joke_book",
                    "scotch_bubble_mailer",
                    "scotch_bubble_mailer",
                    "up_glucose_bottle",
                    "dasani_water_bottle",
                    "dasani_water_bottle",
                    "rawlings_baseball",
                    "folgers_classic_roast_coffee",
                    "elmers_washable_no_run_school_glue",
                    "elmers_washable_no_run_school_glue",
                    "hanes_tube_socks",
                    "womens_knit_gloves",
                    "cherokee_easy_tee_shirt",
                    "peva_shower_curtain_liner",
                    "cloud_b_plush_bear",
                    "barkely_hide_bones",
                    "kyjen_squeakin_eggs_plush_puppies",
                    "cool_shot_glue_sticks",
                    "creativity_chenille_stems",
                    "creativity_chenille_stems",
                    "soft_white_lightbulb",
                    "safety_first_outlet_plugs",
                    "oral_b_toothbrush_green",
                    "oral_b_toothbrush_red",
                    "dr_browns_bottle_brush",
                    "command_hooks",
                    "easter_turtle_sippy_cup",
                    "fiskars_scissors_red",
                    "scotch_duct_tape",
                    "scotch_duct_tape",
                    "woods_extension_cord",
                    "platinum_pets_dog_bowl",
                    "fitness_gear_3lb_dumbbell",
                    "rolodex_jumbo_pencil_cup",
                    "clorox_utility_brush",
                    "kleenex_paper_towels",
                    "expo_dry_erase_board_eraser",
                    "expo_dry_erase_board_eraser",
                    "kleenex_tissue_box",
                    "ticonderoga_12_pencils",
                    "crayola_24_ct",
                    "jane_eyre_dvd",
                    "dove_beauty_bar",
                    "staples_index_cards",
                    "staples_index_cards"]
CONST_NBINS = 12
CONST_NPICKABLE_ITEMS = CONST_NBINS

# do some validitiy testing on the pick input file
# -------------------------------------------------------------------------


def validate_pick_json(json_file):
    # open the pick json file
    print ''
    print ("Checking pick file '%s'") % json_file
    json_pick_data = open(json_file)
    pick_data = json.load(json_pick_data)

    print ''
    print 'Checking that the bin contents meet our contest definition ...'
    bin_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    total_items = 0
    items = copy.deepcopy(CONST_ITEM_NAMES)
    found_bins = []
    if 'bin_contents' in pick_data:
        for bin_name in pick_data['bin_contents']:
            n_items = len(pick_data['bin_contents'][bin_name])
            if n_items < len(bin_counts):
                bin_counts[n_items] = bin_counts[n_items] + 1
            else:
                print (bcolors.FAIL + "  ERROR: Too many items in '%s'" +
                       bcolors.ENDC) % bin_name

            if bin_name in CONST_BIN_NAMES:
                found_bins.append(bin_name)
            else:
                print (bcolors.FAIL + "  ERROR: Unknown bin name '%s'" +
                       bcolors.ENDC) % bin_name

            for item in pick_data['bin_contents'][bin_name]:
                if item in CONST_ITEM_NAMES:
                    if item in items:
                        total_items = total_items + 1
                        items.remove(item)
                    else:
                        print (bcolors.FAIL + "  ERROR: Item '%s' used too many times" +
                               bcolors.ENDC) % item
                else:
                    print (bcolors.FAIL + "  ERROR: Unknown item name '%s'" +
                           bcolors.ENDC) % item
    else:
        print (bcolors.FAIL + "  ERROR: Expected field 'bin_contents' not found." +
               bcolors.ENDC)

    if len(found_bins) < CONST_NBINS:
        print (bcolors.FAIL + "  ERROR: Found %d/%d bins" +
               bcolors.ENDC) % (len(found_bins), CONST_NBINS)

    success = True
    if bin_counts[0] > 0:
        print (bcolors.FAIL + '  ERROR: Found %d empty bins' +
               bcolors.ENDC) % bin_counts[0]
        success = False
    if bin_counts[1] != 1:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 1-item bins' +
               bcolors.ENDC) % (bin_counts[1], 1)
        success = False
    if bin_counts[2] != 3:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 2-item bins' +
               bcolors.ENDC) % (bin_counts[2], 3)
        success = False
    if bin_counts[3] != 2:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 3-item bins' +
               bcolors.ENDC) % (bin_counts[2], 2)
        success = False
    if bin_counts[4] != 3:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 4-item bins' +
               bcolors.ENDC) % (bin_counts[2], 3)
        success = False
    if bin_counts[5] != 1:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 5-item bins' +
               bcolors.ENDC) % (bin_counts[2], 1)
        success = False
    if bin_counts[6] != 0:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 6-item bins' +
               bcolors.ENDC) % (bin_counts[2], 0)
        success = False
    if bin_counts[7] != 1:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 7-item bins' +
               bcolors.ENDC) % (bin_counts[2], 1)
        success = False
    if bin_counts[8] != 0:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 8-item bins' +
               bcolors.ENDC) % (bin_counts[2], 1)
        success = False
    if bin_counts[9] != 1:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 9-item bins' +
               bcolors.ENDC) % (bin_counts[2], 1)
        success = False
    if total_items != len(CONST_ITEM_NAMES):
        print (bcolors.FAIL + '  ERROR: Found %d/%d valid items' +
               bcolors.ENDC) % (total_items, len(CONST_ITEM_NAMES))
        success = False

    if success:
        print (bcolors.OKGREEN +
               '  SUCCESS! Found 1x1, 3x2, 2x3, 3x4, 1x5, 1x8, 1x9 bins for a total of %d items' +
               bcolors.ENDC) % total_items

# -------------------------------------------------------------------------

    print ''
    print 'Checking if the work order is valid ...'
    n_found_items = 0
    found_bins2 = []
    if 'work_order' in pick_data:
        for line_item in pick_data['work_order']:
            item = line_item['item']
            kbin = line_item['bin']

            if kbin in found_bins:
                if item in pick_data['bin_contents'][kbin]:
                    n_found_items = n_found_items + 1
                    # print 'Found item: %s inside of: %s' % (item, kbin)
                else:
                    print (bcolors.FAIL + "  ERROR: Item '%s' does not exist in '%s'" +
                           bcolors.ENDC) % (item, kbin)
                    # break
            else:
                print (bcolors.FAIL + "  ERROR: bin '%s' does not exist in 'bin_contents'" +
                       bcolors.ENDC) % kbin

            if kbin in found_bins2:
                print (bcolors.FAIL + "  ERROR: Redundant bin '%s' found in work order." +
                       bcolors.ENDC) % kbin
            elif kbin in CONST_BIN_NAMES:
                found_bins2.append(kbin)
    else:
        print (bcolors.FAIL + "  ERROR: Expected field 'work_order' not found." +
               bcolors.ENDC)

    success = True
    if n_found_items != CONST_NPICKABLE_ITEMS:
        print (bcolors.FAIL + '  ERROR: Only found %d/%d items.' +
               bcolors.ENDC) % (n_found_items, CONST_NPICKABLE_ITEMS)
        success = False
    if len(found_bins2) != CONST_NBINS:
        print (bcolors.FAIL + '  ERROR: Only found pick items from %d/%d bins.' +
               bcolors.ENDC) % (len(found_bins2), CONST_NBINS)
        success = False
    if success:
        print (bcolors.OKGREEN + '  SUCCESS! Found %d items (1 per bin)' +
               bcolors.ENDC) % CONST_NPICKABLE_ITEMS

    # -------------------------------------------------------------------------

    # close the pick json file
    json_pick_data.close()

# ------------------------------------------------------------------------


def validate_stow_json(json_file):
    # open the stow json file
    print ''
    print ("Checking stow file '%s'") % json_file
    json_stow_data = open(json_file)
    stow_data = json.load(json_stow_data)

    print ''
    print 'Checking that the bin contents meet our contest definition ...'
    bin_counts = [0, 0, 0, 0, 0, 0, 0, 0]
    total_items = 0
    items = copy.deepcopy(CONST_ITEM_NAMES)
    found_bins = []
    if 'bin_contents' in stow_data:
        for bin_name in stow_data['bin_contents']:
            n_items = len(stow_data['bin_contents'][bin_name])
            if n_items < len(bin_counts):
                bin_counts[n_items] = bin_counts[n_items] + 1
            else:
                print (bcolors.FAIL + "  ERROR: Too many items in '%s'" +
                       bcolors.ENDC) % bin_name

            if bin_name in CONST_BIN_NAMES:
                # note: redundant key values overwritten by parser
                found_bins.append(bin_name)
            else:
                print (bcolors.FAIL + "  ERROR: Unknown bin name '%s'" +
                       bcolors.ENDC) % bin_name

            for item in stow_data['bin_contents'][bin_name]:
                if item in CONST_ITEM_NAMES:
                    if item in items:
                        total_items = total_items + 1
                        items.remove(item)
                    else:
                        print (bcolors.FAIL + "  ERROR: Item '%s' used too many times" +
                               bcolors.ENDC) % item
                else:
                    print (bcolors.FAIL + "  ERROR: Unknown item name '%s'" +
                           bcolors.ENDC) % item
    else:
        print (bcolors.FAIL + "  ERROR: Expected field 'bin_contents' not found." +
               bcolors.ENDC)

    if len(found_bins) < CONST_NBINS:
        print (bcolors.FAIL + "  ERROR: Found %d/%d bins" +
               bcolors.ENDC) % (len(found_bins), CONST_NBINS)

    success = True
    if bin_counts[0] > 0:
        print (bcolors.FAIL + '  ERROR: Found %d empty bins' +
               bcolors.ENDC) % bin_counts[0]
        success = False
    if bin_counts[1] != 3:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 1-item bins' +
               bcolors.ENDC) % (bin_counts[1], 3)
        success = False
    if bin_counts[2] != 4:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 2-item bins' +
               bcolors.ENDC) % (bin_counts[2], 4)
        success = False
    if bin_counts[3] != 2:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 3-item bins' +
               bcolors.ENDC) % (bin_counts[2], 2)
        success = False
    if bin_counts[4] != 0:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 4-item bins' +
               bcolors.ENDC) % (bin_counts[2], 0)
        success = False
    if bin_counts[5] != 2:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 5-item bins' +
               bcolors.ENDC) % (bin_counts[2], 2)
        success = False
    if bin_counts[6] != 0:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 6-item bins' +
               bcolors.ENDC) % (bin_counts[2], 0)
        success = False
    if bin_counts[7] != 1:
        print (bcolors.FAIL + '  ERROR: Found %d/%d 7-item bins' +
               bcolors.ENDC) % (bin_counts[2], 1)
        success = False
    if total_items != len(CONST_ITEM_NAMES) - 12:
        print (bcolors.FAIL + '  ERROR: Found %d/%d valid items' +
               bcolors.ENDC) % (total_items, len(CONST_ITEM_NAMES) - 12)
        success = False

    if success:
        print (bcolors.OKGREEN +
               '  SUCCESS! Found 3x1, 4x2, 2x3, 2x5, 1x7 bins for a total of %d items' +
               bcolors.ENDC) % total_items

    # -------------------------------------------------------------------------

    print ''
    print 'Checking if the tote contents are valid ...'
    tote_item_count = 0
    if 'tote_contents' in stow_data:
        for item in stow_data['tote_contents']:
            if item in CONST_ITEM_NAMES:
                if item in items:
                    tote_item_count = tote_item_count + 1
                    total_items = total_items + 1
                    items.remove(item)
                else:
                    print (bcolors.FAIL + "  ERROR: Item '%s' used too many times" +
                           bcolors.ENDC) % item
            else:
                print (bcolors.FAIL + "  ERROR: Unknown item name '%s'" +
                       bcolors.ENDC) % item
    else:
        print (bcolors.FAIL + "  ERROR: Expected field 'tote_contents' not found." +
               bcolors.ENDC)

    success = True
    if tote_item_count != 12:
        print (bcolors.FAIL + "  ERROR: %d/%d items found in tote" +
               bcolors.ENDC) % (tote_item_count, 12)
        success = False

    if total_items != len(CONST_ITEM_NAMES):
        print (bcolors.FAIL + "  ERROR: Accounted for %d/%d total items" +
               bcolors.ENDC) % (total_items, len(CONST_ITEM_NAMES))
        success = False

    if success:
        print (bcolors.OKGREEN +
               '  SUCCESS! Found 12 items in tote that complete item list.' +
               bcolors.ENDC)

    # -------------------------------------------------------------------------

    json_stow_data.close()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--pick-json')
    parser.add_argument('-s', '--stow-json')
    args = parser.parse_args()

    pick_json = args.pick_json
    stow_json = args.stow_json

    if pick_json is None and stow_json is None:
        sys.stderr.write(
            'WARNING: Please specify either pick or stow json file.\n\n')
        parser.print_help()
        sys.exit(1)

    if pick_json is not None:
        validate_pick_json(pick_json)
    if stow_json is not None:
        validate_stow_json(stow_json)


if __name__ == '__main__':
    main()
