#!/usr/bin/env roseus
;; vim: set ft=lisp:
;; -*- mode: lisp;-*-

(ros::roseus "robot_test")

(load "package://jsk_2014_picking_challenge/euslisp/utils.l")
(load "package://jsk_2014_picking_challenge/euslisp/robot-init.l")
(load "package://jsk_2014_picking_challenge/euslisp/robot-utils.l")
(load "package://jsk_2014_picking_challenge/euslisp/robot-interface.l")
(load "package://jsk_2014_picking_challenge/euslisp/robot-motions.l")
(load "package://jsk_2014_picking_challenge/euslisp/robot-communication.l")
(load "package://jsk_2014_picking_challenge/euslisp/debug.l")

(defun test-for-bin (arm bin &key (verify nil))
  (ros::ros-info "test for ~A" bin)
  (move-to-target-bin arm bin)
  (pick-object arm bin)
  (place-object arm))

(defun test-challenge (&key
              (bins (list :a :b :c :d :e :f :g :h :i :j :k :l))
              (use-arm (list :larm :rarm))
              (tweet? t)
              (verify? nil))
  (ros::advertise-if-yet "tweet" std_msgs::string 1)
  (let ((start-time (ros::time-now))
        elapsed-time elapsed-msg arm msg)
    (dolist (bin bins)
      (if (eq (length use-arm) 1) (setq arm (elt use-arm 0))  ;; only use arms in use-arm
        (cond
          ((find bin (list :a :d :g :j)) (setq arm :larm))
          ((find bin (list :c :f :i :l)) (setq arm :rarm))
          (t (setq arm :larm))))
      (test-for-bin arm bin :verify verify?))
    (setq elapsed-time (ros::time- (ros::time-now) start-time))
    (setq elapsed-msg (format nil "It takes ~d min ~d sec" (/ (send elapsed-time :sec) 60) (mod (send elapsed-time :sec) 60)))
    (when tweet? (tweet elapsed-msg))  ;; tweet elapsed time
    ;; return to fold pose and speak
    (send *ri* :angle-vector-sequence (fold-pose-back arm))
    (send *ri* :wait-interpolation)
    (speak-en "Finished picking test." :google t)
    ))

(defun test-return-object (arm bin)
  (do-until-key
    (send *ri* :start-grasp arm)
    (send *ri* :angle-vector (send *baxter* :fold-pose) :fast (arm-to-ctype arm))
    (send *ri* :wait-interpolation)
    (unix::sleep 1)
    (move-to-target-bin arm bin)
    (return-object arm bin)))

(defun test-insert-arm ()
  (let ((bins '(:a :b :c :d :e :f :g :h :i :j :k :l)) arm)
    (dolist (bin bins)
      (case (which-bin-region bin)
        (:center :left (setq arm :larm))
        (:right (setq arm :rarm)))
      (move-to-target-bin arm bin)
      (send *ri* :angle-vector-sequence (insert-to-pick-object-avs arm bin))
      (send *ri* :wait-interpolation)
      (unix::sleep 3)
      (send *ri* :angle-vector (avoid-shelf-pose-for-bin arm bin))
      (send *ri* :wait-interpolation)
      )
    ))

(defun test-pick-object-depth (arm bin)
  ;; insert arm to target bin
  (dolist (av (insert-to-pick-object-avs arm bin))
    (send *irtviewer* :draw-objects)
    (send *ri* :angle-vector av 3000)
    (send *ri* :wait-interpolation))
  (send *ri* :start-grasp arm)
  (dolist (pattern-depth '((:middle . 0) (:middle . 80) (:middle . 150) (:middle . 200)))
    (format t "pattern ~A, depth ~A~%" (car pattern-depth) (cdr pattern-depth))
    (try-to-pick-object arm bin (car pattern-depth) (cdr pattern-depth) :call-check-if-grabbed-function nil))
  (send *ri* :stop-grasp arm)
  )

(defun check-pick ()
  (send *ri* :stop-grasp)
  (dolist (bins '((:a . :c) (:d . :f) (:g . :i) (:j . :l)))
    (format t "move to ~A and ~A~%" (car bins) (cdr bins))
    (when (member (car bins) '(:a :d))
      (fold-to-keep-object-av :larm)
      (fold-to-keep-object-av :rarm)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
      (send *ri* :wait-interpolation))
    (move-to-target-bin :larm (car bins))
    (move-to-target-bin :rarm (cdr bins))
    (test-pick-object-depth :larm (car bins))
    (test-pick-object-depth :rarm (cdr bins))
    ;; back to bin front
    (move-to-target-bin-av :larm (car bins))
    (move-to-target-bin-av :rarm (cdr bins))
    (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
    (send *ri* :wait-interpolation)
    ))

(defun check-pick-offset-impl (arm bin &key (pattern '((:middle . 30) (:middle . 80) (:middle . 150))))
  (let ((last-z nil))
    (dolist (pat pattern)
      (send *ri* :start-grasp arm)
      (catch 'loop
        (dolist (z '(70 75 80 85 90 95 100 105 110 115 120 125 130))
          (insert-to-pick-object-avs arm bin)
          ;;(send *baxter* arm :move-end-rot 2 :y :local :revert-if-fail nil) ;; use same value used in pick-object
          (move-end-rot-with-interpolation arm :y 2 :time 1000)
          (move-end-pos-with-interpolation arm :z (- z) :time 1000)
          (unix:sleep 1)
          (when (check-if-grabbed arm)
            (throw 'loop last-z))
          (setq last-z z)))
      (ros::ros-info "~A ~A ~A ~A safe z is ~A" arm bin (car pat) (cdr pat) last-z)
      (send *ri* :stop-grasp arm)
      ) ;; dolist
    last-z))

;; (check-pick-offset :rarm '(:c :f :i :l) '((:middle . 30)))
;; (check-pick-offset :larm '(:a :d :g :j) '((:middle . 30)))
(defun check-pick-offset (arm &optional (bins '(:c :f :i :l)) (pattern '((:middle . 30) (:middle . 80) (:middle . 150))))
  (let ((limit-map (make-hash-table)))
    (dolist (bin bins)
      (fold-to-keep-object-av arm)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
      (send *ri* :wait-interpolation)
      (move-to-target-bin arm bin)
      (insert-to-pick-object-avs arm bin)
      (send *irtviewer* :draw-objects)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
      (send *ri* :wait-interpolation)
      ;; check
      (setf (gethash bin limit-map) (check-pick-offset-impl arm bin :pattern pattern))
      (insert-to-pick-object-avs arm bin)
      (send *irtviewer* :draw-objects)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
      (send *ri* :wait-interpolation)
      (avoid-shelf-pose-for-bin arm bin)
      (send *irtviewer* :draw-objects)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
      (send *ri* :wait-interpolation)
      (move-to-target-bin arm bin)
      )
    (ros::ros-info "done")
    (format t "(case bin")
    (dolist (bin bins)
      (format t " (~A ~A)" bin (gethash bin limit-map)))
    (format t ")~%")))

(defun check-pick-offset-from-wall-impl (arm bin &key (depth 30) (rotate-angle 2) (side :left))
  (let (limit-dist sign
                   (grasp-side-z 80)
                   (grasp-side-z-down 40)
                   )
    (case side
      (:left (setq sign 1))
      (:right (setq sign -1))
      )
    (catch 'loop
      (dolist (y '(40 50 55 60 65 60 75 80))
        (move-end-pos-with-interpolation arm :x depth :time 100)
        (rotate-wrist arm (* sign 90))
        (send *ri* :angle-vector (send *baxter* :angle-vector) 100)
        (send *ri* :wait-interpolation)
        (move-end-pos-with-interpolation arm :z (- grasp-side-z))
        (send *ri* :start-grasp arm)
        (move-end-rot-with-interpolation arm :x (* sign rotate-angle))
        (move-end-pos-with-interpolation arm :y (* sign y) :z (- grasp-side-z-down) :time 100 :force t)
        (unix::sleep 1) ;; waiting
        (when (check-if-grabbed arm)
          (throw 'loop limit-dist))
        (setq limit-dist y)
        ;; return to original pose
        (insert-to-pick-object-avs arm bin)
        (send *irtviewer* :draw-objects)
        (send *ri* :angle-vector (send *baxter* :angle-vector) 100)
        (send *ri* :wait-interpolation)
        ))
    (insert-to-pick-object-avs arm bin)
    (send *irtviewer* :draw-objects)
    (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
    (send *ri* :wait-interpolation)
    (ros::ros-info "arm: ~A bin: ~A depth: ~A safe ~A is ~A" arm bin depth side limit-dist)
    (send *ri* :stop-grasp arm)
    limit-dist))


(defun check-pick-offset-from-wall (arm &key (bins '(:c)) (depths '(30)) (angles '(0)))
  (let ((limit-map (make-hash-table :test #'equal)) dict)
    (labels ((add-key (key value)
                      (push (cons key value) dict)
                      (assoc key dict)))
        (dolist (bin bins)
          (dolist (depth depths)
            (dolist (angle angles)
              (setq dict nil)
              ;; move into shelf
              (fold-to-keep-object-av arm)
              (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
              (send *ri* :wait-interpolation)
              (move-to-target-bin arm bin)
              (insert-to-pick-object-avs arm bin)
              (send *irtviewer* :draw-objects)
              (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
              (send *ri* :wait-interpolation)

              (add-key :bin bin)
              (add-key :angle angle)
              (add-key :depth depth)
              (setf (gethash '(bin angle depth) limit-map) (list
                                                            (add-key :left (check-pick-offset-from-wall-impl arm bin :side :left :rotate-angle 0))
                                                            (add-key :right (check-pick-offset-from-wall-impl arm bin :side :right :rotate-angle 0))
                                                            ))
              (insert-to-pick-object-avs arm bin)
              (send *irtviewer* :draw-objects)
              (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
              (send *ri* :wait-interpolation)
              (avoid-shelf-pose-for-bin arm bin)
              (send *irtviewer* :draw-objects)
              (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
              (send *ri* :wait-interpolation)
              (move-to-target-bin arm bin)
              )))
        (ros::ros-info "done")
        (format t "(case ")
        (dolist (bin bins)
          (dolist (depth depths)
            (dolist (angle angles)
              (format t " (:bin ~A :depth ~A :angle ~A ~A)~%" bin depth angle (gethash '(bin angle depth) limit-map)))))
        (format t ")~%"))))

(defun check-single-motion-of-pick-object (arm bin &key (pattern :middle) (depth 30))
  ;; move into shelf
  (insert-to-pick-object-avs arm bin)
  (send *irtviewer* :draw-objects)
  (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
  (send *ri* :wait-interpolation)
  (try-to-pick-object arm bin pattern depth :debug-mode t)
  (insert-to-pick-object-avs arm bin)
  (send *irtviewer* :draw-objects)
  (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
  (send *ri* :wait-interpolation)
  )

(defun check-all-motion-of-pick-object (arm bin)
  (let ((patterns '((:middle . 30) (:middle . 80) (:middle . 150) (:right-most . 80) (:left-most . 80)
                    (:rotate-and-left . 30) (:rotate-and-right . 30))))
    (move-to-target-bin arm bin)
    (dolist (pattern patterns)
      (check-single-motion-of-pick-object arm bin :pattern (car pattern) :depth (cdr pattern))
      )
    )
  )


(apc-init)
(warn "~% Commands ~%")
(warn "(check-pick) : Check all pick motion~%")
(warn "(check-pick-offset) : Check all offset~%")
(warn "(check-pick-offset-from-wall) : Check rotate-and-left/right's offset~%")
(warn "(check-all-motion-of-pick-object) Check motion of pick-object~%")
